// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"createmod/model"
)

func newQeyKryWEwfwaffailure(db *gorm.DB, opts ...gen.DOOption) qeyKryWEwfwaffailure {
	_qeyKryWEwfwaffailure := qeyKryWEwfwaffailure{}

	_qeyKryWEwfwaffailure.qeyKryWEwfwaffailureDo.UseDB(db, opts...)
	_qeyKryWEwfwaffailure.qeyKryWEwfwaffailureDo.UseModel(&model.QeyKryWEwfwaffailure{})

	tableName := _qeyKryWEwfwaffailure.qeyKryWEwfwaffailureDo.TableName()
	_qeyKryWEwfwaffailure.ALL = field.NewAsterisk(tableName)
	_qeyKryWEwfwaffailure.ID = field.NewInt32(tableName, "id")
	_qeyKryWEwfwaffailure.Throwable = field.NewString(tableName, "throwable")
	_qeyKryWEwfwaffailure.RuleID = field.NewInt32(tableName, "rule_id")
	_qeyKryWEwfwaffailure.Timestamp = field.NewTime(tableName, "timestamp")

	_qeyKryWEwfwaffailure.fillFieldMap()

	return _qeyKryWEwfwaffailure
}

type qeyKryWEwfwaffailure struct {
	qeyKryWEwfwaffailureDo

	ALL       field.Asterisk
	ID        field.Int32
	Throwable field.String
	RuleID    field.Int32
	Timestamp field.Time

	fieldMap map[string]field.Expr
}

func (q qeyKryWEwfwaffailure) Table(newTableName string) *qeyKryWEwfwaffailure {
	q.qeyKryWEwfwaffailureDo.UseTable(newTableName)
	return q.updateTableName(newTableName)
}

func (q qeyKryWEwfwaffailure) As(alias string) *qeyKryWEwfwaffailure {
	q.qeyKryWEwfwaffailureDo.DO = *(q.qeyKryWEwfwaffailureDo.As(alias).(*gen.DO))
	return q.updateTableName(alias)
}

func (q *qeyKryWEwfwaffailure) updateTableName(table string) *qeyKryWEwfwaffailure {
	q.ALL = field.NewAsterisk(table)
	q.ID = field.NewInt32(table, "id")
	q.Throwable = field.NewString(table, "throwable")
	q.RuleID = field.NewInt32(table, "rule_id")
	q.Timestamp = field.NewTime(table, "timestamp")

	q.fillFieldMap()

	return q
}

func (q *qeyKryWEwfwaffailure) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := q.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (q *qeyKryWEwfwaffailure) fillFieldMap() {
	q.fieldMap = make(map[string]field.Expr, 4)
	q.fieldMap["id"] = q.ID
	q.fieldMap["throwable"] = q.Throwable
	q.fieldMap["rule_id"] = q.RuleID
	q.fieldMap["timestamp"] = q.Timestamp
}

func (q qeyKryWEwfwaffailure) clone(db *gorm.DB) qeyKryWEwfwaffailure {
	q.qeyKryWEwfwaffailureDo.ReplaceConnPool(db.Statement.ConnPool)
	return q
}

func (q qeyKryWEwfwaffailure) replaceDB(db *gorm.DB) qeyKryWEwfwaffailure {
	q.qeyKryWEwfwaffailureDo.ReplaceDB(db)
	return q
}

type qeyKryWEwfwaffailureDo struct{ gen.DO }

type IQeyKryWEwfwaffailureDo interface {
	gen.SubQuery
	Debug() IQeyKryWEwfwaffailureDo
	WithContext(ctx context.Context) IQeyKryWEwfwaffailureDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IQeyKryWEwfwaffailureDo
	WriteDB() IQeyKryWEwfwaffailureDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IQeyKryWEwfwaffailureDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IQeyKryWEwfwaffailureDo
	Not(conds ...gen.Condition) IQeyKryWEwfwaffailureDo
	Or(conds ...gen.Condition) IQeyKryWEwfwaffailureDo
	Select(conds ...field.Expr) IQeyKryWEwfwaffailureDo
	Where(conds ...gen.Condition) IQeyKryWEwfwaffailureDo
	Order(conds ...field.Expr) IQeyKryWEwfwaffailureDo
	Distinct(cols ...field.Expr) IQeyKryWEwfwaffailureDo
	Omit(cols ...field.Expr) IQeyKryWEwfwaffailureDo
	Join(table schema.Tabler, on ...field.Expr) IQeyKryWEwfwaffailureDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IQeyKryWEwfwaffailureDo
	RightJoin(table schema.Tabler, on ...field.Expr) IQeyKryWEwfwaffailureDo
	Group(cols ...field.Expr) IQeyKryWEwfwaffailureDo
	Having(conds ...gen.Condition) IQeyKryWEwfwaffailureDo
	Limit(limit int) IQeyKryWEwfwaffailureDo
	Offset(offset int) IQeyKryWEwfwaffailureDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IQeyKryWEwfwaffailureDo
	Unscoped() IQeyKryWEwfwaffailureDo
	Create(values ...*model.QeyKryWEwfwaffailure) error
	CreateInBatches(values []*model.QeyKryWEwfwaffailure, batchSize int) error
	Save(values ...*model.QeyKryWEwfwaffailure) error
	First() (*model.QeyKryWEwfwaffailure, error)
	Take() (*model.QeyKryWEwfwaffailure, error)
	Last() (*model.QeyKryWEwfwaffailure, error)
	Find() ([]*model.QeyKryWEwfwaffailure, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.QeyKryWEwfwaffailure, err error)
	FindInBatches(result *[]*model.QeyKryWEwfwaffailure, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.QeyKryWEwfwaffailure) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IQeyKryWEwfwaffailureDo
	Assign(attrs ...field.AssignExpr) IQeyKryWEwfwaffailureDo
	Joins(fields ...field.RelationField) IQeyKryWEwfwaffailureDo
	Preload(fields ...field.RelationField) IQeyKryWEwfwaffailureDo
	FirstOrInit() (*model.QeyKryWEwfwaffailure, error)
	FirstOrCreate() (*model.QeyKryWEwfwaffailure, error)
	FindByPage(offset int, limit int) (result []*model.QeyKryWEwfwaffailure, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IQeyKryWEwfwaffailureDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (q qeyKryWEwfwaffailureDo) Debug() IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.Debug())
}

func (q qeyKryWEwfwaffailureDo) WithContext(ctx context.Context) IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.WithContext(ctx))
}

func (q qeyKryWEwfwaffailureDo) ReadDB() IQeyKryWEwfwaffailureDo {
	return q.Clauses(dbresolver.Read)
}

func (q qeyKryWEwfwaffailureDo) WriteDB() IQeyKryWEwfwaffailureDo {
	return q.Clauses(dbresolver.Write)
}

func (q qeyKryWEwfwaffailureDo) Session(config *gorm.Session) IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.Session(config))
}

func (q qeyKryWEwfwaffailureDo) Clauses(conds ...clause.Expression) IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.Clauses(conds...))
}

func (q qeyKryWEwfwaffailureDo) Returning(value interface{}, columns ...string) IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.Returning(value, columns...))
}

func (q qeyKryWEwfwaffailureDo) Not(conds ...gen.Condition) IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.Not(conds...))
}

func (q qeyKryWEwfwaffailureDo) Or(conds ...gen.Condition) IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.Or(conds...))
}

func (q qeyKryWEwfwaffailureDo) Select(conds ...field.Expr) IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.Select(conds...))
}

func (q qeyKryWEwfwaffailureDo) Where(conds ...gen.Condition) IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.Where(conds...))
}

func (q qeyKryWEwfwaffailureDo) Order(conds ...field.Expr) IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.Order(conds...))
}

func (q qeyKryWEwfwaffailureDo) Distinct(cols ...field.Expr) IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.Distinct(cols...))
}

func (q qeyKryWEwfwaffailureDo) Omit(cols ...field.Expr) IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.Omit(cols...))
}

func (q qeyKryWEwfwaffailureDo) Join(table schema.Tabler, on ...field.Expr) IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.Join(table, on...))
}

func (q qeyKryWEwfwaffailureDo) LeftJoin(table schema.Tabler, on ...field.Expr) IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.LeftJoin(table, on...))
}

func (q qeyKryWEwfwaffailureDo) RightJoin(table schema.Tabler, on ...field.Expr) IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.RightJoin(table, on...))
}

func (q qeyKryWEwfwaffailureDo) Group(cols ...field.Expr) IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.Group(cols...))
}

func (q qeyKryWEwfwaffailureDo) Having(conds ...gen.Condition) IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.Having(conds...))
}

func (q qeyKryWEwfwaffailureDo) Limit(limit int) IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.Limit(limit))
}

func (q qeyKryWEwfwaffailureDo) Offset(offset int) IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.Offset(offset))
}

func (q qeyKryWEwfwaffailureDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.Scopes(funcs...))
}

func (q qeyKryWEwfwaffailureDo) Unscoped() IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.Unscoped())
}

func (q qeyKryWEwfwaffailureDo) Create(values ...*model.QeyKryWEwfwaffailure) error {
	if len(values) == 0 {
		return nil
	}
	return q.DO.Create(values)
}

func (q qeyKryWEwfwaffailureDo) CreateInBatches(values []*model.QeyKryWEwfwaffailure, batchSize int) error {
	return q.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (q qeyKryWEwfwaffailureDo) Save(values ...*model.QeyKryWEwfwaffailure) error {
	if len(values) == 0 {
		return nil
	}
	return q.DO.Save(values)
}

func (q qeyKryWEwfwaffailureDo) First() (*model.QeyKryWEwfwaffailure, error) {
	if result, err := q.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.QeyKryWEwfwaffailure), nil
	}
}

func (q qeyKryWEwfwaffailureDo) Take() (*model.QeyKryWEwfwaffailure, error) {
	if result, err := q.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.QeyKryWEwfwaffailure), nil
	}
}

func (q qeyKryWEwfwaffailureDo) Last() (*model.QeyKryWEwfwaffailure, error) {
	if result, err := q.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.QeyKryWEwfwaffailure), nil
	}
}

func (q qeyKryWEwfwaffailureDo) Find() ([]*model.QeyKryWEwfwaffailure, error) {
	result, err := q.DO.Find()
	return result.([]*model.QeyKryWEwfwaffailure), err
}

func (q qeyKryWEwfwaffailureDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.QeyKryWEwfwaffailure, err error) {
	buf := make([]*model.QeyKryWEwfwaffailure, 0, batchSize)
	err = q.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (q qeyKryWEwfwaffailureDo) FindInBatches(result *[]*model.QeyKryWEwfwaffailure, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return q.DO.FindInBatches(result, batchSize, fc)
}

func (q qeyKryWEwfwaffailureDo) Attrs(attrs ...field.AssignExpr) IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.Attrs(attrs...))
}

func (q qeyKryWEwfwaffailureDo) Assign(attrs ...field.AssignExpr) IQeyKryWEwfwaffailureDo {
	return q.withDO(q.DO.Assign(attrs...))
}

func (q qeyKryWEwfwaffailureDo) Joins(fields ...field.RelationField) IQeyKryWEwfwaffailureDo {
	for _, _f := range fields {
		q = *q.withDO(q.DO.Joins(_f))
	}
	return &q
}

func (q qeyKryWEwfwaffailureDo) Preload(fields ...field.RelationField) IQeyKryWEwfwaffailureDo {
	for _, _f := range fields {
		q = *q.withDO(q.DO.Preload(_f))
	}
	return &q
}

func (q qeyKryWEwfwaffailureDo) FirstOrInit() (*model.QeyKryWEwfwaffailure, error) {
	if result, err := q.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.QeyKryWEwfwaffailure), nil
	}
}

func (q qeyKryWEwfwaffailureDo) FirstOrCreate() (*model.QeyKryWEwfwaffailure, error) {
	if result, err := q.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.QeyKryWEwfwaffailure), nil
	}
}

func (q qeyKryWEwfwaffailureDo) FindByPage(offset int, limit int) (result []*model.QeyKryWEwfwaffailure, count int64, err error) {
	result, err = q.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = q.Offset(-1).Limit(-1).Count()
	return
}

func (q qeyKryWEwfwaffailureDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = q.Count()
	if err != nil {
		return
	}

	err = q.Offset(offset).Limit(limit).Scan(result)
	return
}

func (q qeyKryWEwfwaffailureDo) Scan(result interface{}) (err error) {
	return q.DO.Scan(result)
}

func (q qeyKryWEwfwaffailureDo) Delete(models ...*model.QeyKryWEwfwaffailure) (result gen.ResultInfo, err error) {
	return q.DO.Delete(models)
}

func (q *qeyKryWEwfwaffailureDo) withDO(do gen.Dao) *qeyKryWEwfwaffailureDo {
	q.DO = *do.(*gen.DO)
	return q
}
